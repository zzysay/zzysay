<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://zzysay.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="最早将深度学习应用到关系抽取的文章出现在COLING 2014上，近年来，基于深度学习的关系抽取呈现出蓬勃发展的趋势。但一直以来，学者们大都致力于解决远程监督标注数据产生的噪声问题，将一些在通用自然语言处理任务中效果很好的方法应用到关系抽取任务上。直到2018年，随着一些新技术和新思路的出现，学者们不再聚焦于传统的去噪任务，逐渐开始针对关系抽取任务的特点进行一些深入分析和大胆尝试。本文从2018年">
<meta name="keywords" content="自然语言处理,知识图谱,关系抽取">
<meta property="og:type" content="article">
<meta property="og:title" content="基于深度学习的关系抽取最新进展(2018)">
<meta property="og:url" content="http://zzysay.github.io/2019/01/08/nlp-dl4re-v2/index.html">
<meta property="og:site_name" content="ZZY SAY">
<meta property="og:description" content="最早将深度学习应用到关系抽取的文章出现在COLING 2014上，近年来，基于深度学习的关系抽取呈现出蓬勃发展的趋势。但一直以来，学者们大都致力于解决远程监督标注数据产生的噪声问题，将一些在通用自然语言处理任务中效果很好的方法应用到关系抽取任务上。直到2018年，随着一些新技术和新思路的出现，学者们不再聚焦于传统的去噪任务，逐渐开始针对关系抽取任务的特点进行一些深入分析和大胆尝试。本文从2018年">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519451227443.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519452105468.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519453561228.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519454011564.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519456325466.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519456619877.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519457568216.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519457646002.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519457845589.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519457945842.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519459138774.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519459378535.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519460227458.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519460582502.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519462041036.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519462125899.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519462237052.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519463790659.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519463923015.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519464573760.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519464657890.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519465874810.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519466599452.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519466710066.jpg">
<meta property="og:image" content="http://qiniu.zzysay.cn/15519466837523.jpg">
<meta property="og:updated_time" content="2020-01-29T13:07:46.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于深度学习的关系抽取最新进展(2018)">
<meta name="twitter:description" content="最早将深度学习应用到关系抽取的文章出现在COLING 2014上，近年来，基于深度学习的关系抽取呈现出蓬勃发展的趋势。但一直以来，学者们大都致力于解决远程监督标注数据产生的噪声问题，将一些在通用自然语言处理任务中效果很好的方法应用到关系抽取任务上。直到2018年，随着一些新技术和新思路的出现，学者们不再聚焦于传统的去噪任务，逐渐开始针对关系抽取任务的特点进行一些深入分析和大胆尝试。本文从2018年">
<meta name="twitter:image" content="http://qiniu.zzysay.cn/15519451227443.jpg">

<link rel="canonical" href="http://zzysay.github.io/2019/01/08/nlp-dl4re-v2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>基于深度学习的关系抽取最新进展(2018) | ZZY SAY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZZY SAY</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">All in the Game</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://zzysay.github.io/2019/01/08/nlp-dl4re-v2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Zhenyu Zhang">
      <meta itemprop="description" content="Survival with technology<br/>And living with art">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZZY SAY">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于深度学习的关系抽取最新进展(2018)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-08 16:35:43" itemprop="dateCreated datePublished" datetime="2019-01-08T16:35:43+08:00">2019-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-29 21:07:46" itemprop="dateModified" datetime="2020-01-29T21:07:46+08:00">2020-01-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study-Notes/" itemprop="url" rel="index">
                    <span itemprop="name">Study Notes</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Study-Notes/Nature-Language-Processing/" itemprop="url" rel="index">
                    <span itemprop="name">Nature Language Processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最早将深度学习应用到关系抽取的文章出现在COLING 2014上，近年来，基于深度学习的关系抽取呈现出蓬勃发展的趋势。但一直以来，学者们大都致力于解决远程监督标注数据产生的噪声问题，将一些在通用自然语言处理任务中效果很好的方法应用到关系抽取任务上。直到2018年，随着一些新技术和新思路的出现，学者们不再聚焦于传统的去噪任务，逐渐开始针对关系抽取任务的特点进行一些深入分析和大胆尝试。本文从2018年人工智能和自然语言处理的顶级会议中选取了部分相关论文进行简单介绍，希望能够从中发现关系抽取的最新发展方向。</p>
<a id="more"></a>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>本文搜集了2018年AAAI、IJCAI、ACL、COLING、EMNLP上所有和关系抽取/关系分类相关的论文，共计31篇（见附录），总体来看，这些会议和论文的出发点大都为神经网络模型和相关的语言学知识，所涉及的技术包括强化学习、生成对抗网络、胶囊网络、图卷积网络等。</p>
<p>按照论文要解决的问题，本文将它们分成四大类：</p>
<p>a）模型去噪：使用模型方法来解决远程监督的噪声问题；</p>
<p>b）外部知识：通过融入外部知识或知识库知识来提升总体性能； </p>
<p>c）关系重叠：使用新模型来解决一句话中出现多个关系的情况； </p>
<p>d）其他：包括联合学习、跨句子关系抽取、少样本学习等等。</p>
<p>注意力机制出现之后，学者们倾向于使用各种各样的注意力机制来降低噪声的干扰，但是18年的几篇文章有了新的思考，开始关注句子本身的一些结构信息，例如SDP，STP，LCA等等。融入外部知识是今年的主流方向，因为关系抽取最直接的任务就是知识库扩充，知识库中大量的结构化知识一直以来都未得到充分的利用。关系重叠问题的解决方案相对较少，胶囊网络和编码解码模型为这个问题的解决提供了新的思路，除此之外，联合学习和跨句子的关系抽取依旧是值得关注的研究点。</p>
<p>接下来，本文分四个部分，分别对上述每一类的代表性文章进行探讨分析。</p>
<h2 id="模型去噪"><a href="#模型去噪" class="headerlink" title="模型去噪"></a>模型去噪</h2><h3 id="AAAI-2018-CNN-RL"><a href="#AAAI-2018-CNN-RL" class="headerlink" title="[AAAI 2018] CNN+RL"></a>[AAAI 2018] CNN+RL</h3><p><strong>Reinforcement Learning for Relation Classification from Noisy Data</strong></p>
<p>这是来自清华大学黄民烈老师组的工作，文章的目的是解决远程监督标注数据集的错误标签问题。为了减少噪声数据对模型的影响，我们希望能够训练一个模型实现对样本的筛选，从而得到一个高质量的数据集。在对样本进行筛选时，往往无法直接判断每个样本的好坏，只能在全部样本选择完成后，集中评价整个数据集的质量，这种延迟反馈的方法天然适合强化学习的框架。</p>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><center><br><img src="http://qiniu.zzysay.cn/15519451227443.jpg" width="400/"><br></center>

<p>模型框架如图所示，左边是句子选择器，右边是一个经典的基于卷积神经网络的关系分类器。句子选择器根据 policy 函数对样本逐个筛选，每个样本都可以执行选或者不选两种 action，筛选完之后会生成一个新的数据集，policy 函数定义如下：</p>
<p>$$\pi_{\theta}(s_i, a_i) = P_{\theta}(a_i|s_i) = a_i\sigma(W·F(s_i) + b) + (1-a_i)(1-\sigma(W·F(s_i) + b)) $$</p>
<p>其中 $a_i \in {0,1}$ 表示是否选择当前句子，$s_i$ 是表示当前句子的状态，包括当前句子、已选择的句子和当前包的实体对信息。$F(s_i)$ 是状态特征向量，同样也包括以上三个部分，$\sigma$ 是 sigmoid 函数。</p>
<p>接下来，模型用关系分类器来评价选择的句子集的好坏，并计算出一个 reward，再使用 policy gradient 来更新 policy 函数的参数。显然，只有当句子的选择状态全都确定后，才能计算 reward，所以 reward 定义如下：</p>
<p>$$ r(s_i|B) = \begin{cases} 0 &amp; \text{if i &lt; |B| + 1} \\ \frac 1 {|\hat B|} \sum_{x_j \in |\hat B|} \log p(r|x_j) &amp; \text{if i = |B| + 1} \end{cases} $$</p>
<p>其中，$B$ 代表一个示例包，$|\hat B|$ 表示筛选后得到的新示例包。为了得到更多的反馈，提高训练效率，论文将样本按照实体对分成若干个示例包，每次句子选择器完成一个包的选择后，模型都会用关系分类器来评估这部分数据，并更新 policy 函数的参数。当所有包都训练完成之后，再筛选出所有的样本，训练更新关系分类器的参数，从而得到最终的模型来用于关系预测。</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集上进行，通过与当前主流深度神经网络方法的比较，来证明强化学习的方法在数据筛选方面的卓越性能。</p>
<p>从下表可以看出，基于强化学习的方法比当前基于池化和注意力机制的方法在性能上都高出很多，需要注意的一点是，这里的评价的是句子级别的准确率。</p>
<p><img src="http://qiniu.zzysay.cn/15519452105468.jpg" alt=""></p>
<p>实验还使用保留集比较了句子质量和句子选择策略对模型效果的影响。由上图中的图 3 可以看出，使用句子选择器筛选后的数据集训练出了更好的关系分类模型，这也就意味着强化学习对句子的筛选在提高模型性能方面起到了一定的作用。此外，文章还通过实验说明，在对句子的选择上，强化学习的方法优于使用贪心策略的方法。</p>
<h3 id="ACL-2018-DSGAN"><a href="#ACL-2018-DSGAN" class="headerlink" title="[ACL 2018] DSGAN"></a>[ACL 2018] DSGAN</h3><blockquote>
<p><strong>DSGAN: Generative Adversarial Training for Distant Supervision Relation Extraction</strong></p>
</blockquote>
<p>这是来自UCSB王威廉老师组的工作，论文使用生成对抗网络（GAN）来解决远程监督的噪声数据问题，按照GAN的框架思想，在生成器生成数据划分之后，判别器来评价该划分的好坏，并将结果反馈给生成器，生成器根据反馈进一步生成新的数据，希望能够最大限度地降低判别器的判别能力。</p>
<h4 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519453561228.jpg" alt=""></p>
<p>模型的整体结构如上图所示，给定一个使用远程监督标注的数据集，生成器希望从中选择出全部的真正例，但是在整个框架中，这些被选择出来的正例却被看作为负例来训练判别器，没有被选择出来的样本却被当做正例。最后，生成器发现越多的正例，那么被标记的负例也就越多，判别器的性能下降也就越多。这样一来，我们的目标就是希望得到一个强大的生成器，以至于在最大程度上使得判别器丧失分类能力。显然，在这个迭代过程开始之前，我们需要对判别器进行预训练。</p>
<p>为了获得更多的反馈，我们把整个正例集合划分成了 $N$ 个包，每处理完一个包，就更新一次模型参数。我们把第 $i$ 个包记作 $B_i$，对于其中的一个句子 $s_j$, 定义其被生成器判断为真正例的概率为 $p_G(s_j)$，其被判别器判断为真正例的概率为 $p_D(s_j)$。</p>
<p>生成器基于 $p_G(s_j)$ 来选出高概率的句子组成一个集合 $T$：</p>
<p>$$T={s_j}, \; s_j \sim p_G(s_j), \; j=1,2,…,|B_i|$$</p>
<p>显然，生成器的目标就是使得选择出的真正例集合 $T$ 的概率最大；</p>
<p>$$ \max L_G = \sum_{s_j\in T} \log p_D(s_j) $$</p>
<p>判别器将 $T$ 中的样本标签置为 0，剩余的样本标签置为 1。训练目标就是最小化二分类的交叉熵损失：</p>
<p>$$ \min L_D = -(\sum_{s_j\in(B_i-T)}\log p_D(s_j) + \sum_{s_j\in T} \log (1-p_D(s_j))) $$</p>
<p>生成器选择句子是离散的采样过程，不能直接基于梯度来优化网络，论文使用强化学习来解决这一问题。此外，判别器在每一个epoch开始时加载的都是同一套预训练的参数。这样做的原因有两个，首先，我们最后需要的是生成器而不是判别器。其次，在迭代过程中，生成器面向的是原始的数据而不是生成的新数据。综合来看，文章的亮点在于将判别器的目标逆向思考，即把生成器选择的正样本标记为负样本，使用判别器性能下降的程度来衡量生成器选择数据的质量。</p>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p>实验首先在三种关系上分别探讨了不同的训练策略在训练过程中的收敛速度和表现性能，随后也展示了生成器在这三种关系上生成数据的准确率，最后在 NYT 数据集上进行关系抽取的实验。</p>
<center><br><img src="http://qiniu.zzysay.cn/15519454011564.jpg" width="400/"><br></center>


<p>根据使用不同的判别器，文章把实验分成了两大组，一组是基于CNN的判别器，另一组是基于PCNN的判别器，通过上表可以看出，加入DSGAN策略后，AUC值普遍提升了1-2个点，从而说明这是一种十分有效的句子选择（去噪）手段。</p>
<h3 id="EMNLP-2018-STP-TL"><a href="#EMNLP-2018-STP-TL" class="headerlink" title="[EMNLP 2018] STP+TL"></a>[EMNLP 2018] STP+TL</h3><blockquote>
<p><strong>Neural Relation Extraction via Inner-Sentence Noise Reduction and Transfer Learning</strong></p>
</blockquote>
<p>这是来自上海交通大学的工作，在远程监督场景下，除了语料的错误标注问题，还存在句内噪声单词过多的问题，这个问题一直没有引起足够的重视，并且，随机初始化特征抽取器参数的方法过于粗暴。文章分别使用子树解析和迁移学习的方法来解决这两个问题。同时，这也是第一篇在关系抽取任务中使用迁移学习的文章。</p>
<h4 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519456325466.jpg" alt=""></p>
<p>上图的框架可以大致分为三个部分，第一个部分是子树解析（Sub-Tree Parse），对句子进行句法解析后，找到两个实体最近的公共祖先，取以该祖先节点的父节点为根节点的子树，只保留句子中的这些单词。随后将原始句子包的 STP 输入到网络中，经过一个 Bi-GRU 来编码句子的语义，第二个部分就是编码器中的注意力机制，编码器中不仅含有单词级别的注意力机制和句子级别的注意力机制，还增加了一个面向实体的注意力机制：</p>
<p>$$ \alpha_{it}^e = \begin{cases} 1, &amp; t\;=\;head, tail \\ 0, &amp; others \end{cases};  \quad<br>   \alpha_{it}^w = \frac{\exp(h_{it}A^wr^w)}{\sum_{t^{‘}=1}^T\exp(h_{it^{‘}}A^wr^w)}; \quad<br>   \alpha_{i}^s = \frac {\exp(S_iA^sr^s)} {\sum_j\exp(S_jA^sr^s)}$$</p>
<p>$$ S_i = \sum_t(\alpha_{it}^w + \alpha_{it}^e)h_{it}; \quad<br>   S = \sum_i \alpha_i^s S_i $$    </p>
<p>其中，$r^s$ 是关系向量，$r^w$ 是一个随机初始化的上下文查询向量，并随着网络训练逐步学习，直观上可以看成为了判断哪些词语有更多信息而引入的一个<a href="http://aclweb.org/anthology/N16-1174.pdf" target="_blank" rel="noopener">高级表示</a>。</p>
<p>框架的第三个部分就是模型参数的初始化，这里使用一个实体类型分类的任务来初始化模型的一部分参数：</p>
<p>$$ \hat{p}^{t} = softmax(W_{t}S_{t} + b_{t}); \quad t \in {head, tail};  \quad\quad \hat{p}^{r} = softmax(W_{r}S_{r} + b_{r}) $$</p>
<p>实体分类和关系分类任务共享除了注意力层和输出层的所有参数，需要注意的是，对头实体和尾实体的分类分别是两个不同的任务，使用的也是两套不同的参数（笔者注：在对头实体预测时，实体级别的注意力机制可能只关注头实体，反之亦然）。在最后的训练过程中，首先训练两个实体分类任务，随后将共享层的参数迁移到关系分类任务上，作为模型的初始化，最后再进一步优化与关系分类任务相关的参数。</p>
<h4 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集上进行，首先使用 PR 曲线来分别展示文章中三个模块的具体作用，每一个功能模块的增加都对最终的结果产生了明显的提升，尤其是 STP 部分和迁移学习部分。</p>
<p>值得一提的是，在STP部分，实验表明了使用SDP比使用整个句子有小幅度的提升，相较于前两个部分，STP的提升则十分显著，这是一种符合数据分布的结果，因为 SDP 在去除噪音词的同时，也误删了很多对关系分类来说十分有意义的词汇。</p>
<p><img src="http://qiniu.zzysay.cn/15519456619877.jpg" alt=""></p>
<p>通过表 3 可以发现，相比于 PCNN + ATT，这种方法取得了6-7个点的性能提升。在不使用迁移学习的情况下，就取得了不错的效果，从而也说明了 STP 和实体级别的注意力机制都是十分有效的方法。此外，预训练和迁移学习对模型效果的提升可能不限于此，选择更合适的预训练任务可能能够取得更好的效果。</p>
<h2 id="外部知识"><a href="#外部知识" class="headerlink" title="外部知识"></a>外部知识</h2><h3 id="COLING-2018-CORD"><a href="#COLING-2018-CORD" class="headerlink" title="[COLING 2018] CORD"></a>[COLING 2018] CORD</h3><blockquote>
<p><strong>Cooperative Denoising for Distantly Supervised Relation Extraction</strong></p>
</blockquote>
<p>这是来自北京大学深圳研究生院和腾讯 Medical AI Lab的工作，合作作者还有中科院深研院的杨敏老师。文章认为，当前的很多方法都仅仅局限于语料集，知识图谱中的很多信息都未得到充分利用，充分利用各种信息源的监督信息，有利于缓解远程监督中的噪声标签问题。此外，论文还获得了COLING 2018 Best Paper的提名。</p>
<h4 id="模型-3"><a href="#模型-3" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519457568216.jpg" alt=""></p>
<p>文章提出了一种协同去噪框架CORD，该框架由Corpus-Net、KG-Net两个神经网络和一个协同模块组成，两个神经网络分别在文本语料库和知识图谱中进行学习，再通过一个自适应的双向知识蒸馏模块（Adaptive Bi-directional Knowledge Distillation）完成它们间的相互学习，并结合一些实体类型的约束，最终达到去除噪声的目的。</p>
<p><img src="http://qiniu.zzysay.cn/15519457646002.jpg" alt=""></p>
<p>其中，Corpus-Net 和 <a href="http://aclweb.org/anthology/P16-1200.pdf" target="_blank" rel="noopener">PCNN +ATT</a> 几乎完全相同，只是把编码器换成了 Bi-GRU。KG-Net 的输入是从句子中识别出的实体在知识库中对应的候选实体序列，这些候选实体经过一个链指级别的注意力机制（候选实体向量预先使用 DeepWalk 和 TransE 得到），得到对应实体的向量表示，与该实体在原句子中的位置向量拼接后输入到一个 Bi-GRU 中，再经过一个实体级别的注意力机制，就可以得到基于知识图谱的句子表示。</p>
<p>文章还关注了关系的特定规则，因为一些典型的错误可以通过这种规则来纠正，比如两个实体的类型都为 person，那么其关系就不可能是 born_in，这种规则信息可以大规模地从 Freebase 中统计得出。给定一个实体对中两个实体的所有实体类型 $t_{j,1}$ 和 $t_{j,2}$，我们给每个关系 $i$ 设计了一个逻辑规则：$r_i= (T_{i,1} \in t_{j,1}) \land (T_{i,2} \in t_{j,2})$，即关系对应的头尾实体的类型需要在对应位置实体的类型集合中出现过。这里沿用<a href="http://jmlr.org/papers/volume18/15-631/15-631.pdf" target="_blank" rel="noopener">前人的工作</a>使用了一种软逻辑，使得这个规则得分取值在 [0,1] 之间。这样，我们就可以使用后验正则化的方式将原预测结果 $p(S^e)$ 投影到新的约束子空间 $(p^{‘}(S^e))^*$  中去：</p>
<p>$$ (p^{‘}(S^e))^* \propto p(S^e) \times e^{s_r}, \quad \quad s_r = -\sum_{i=1}^l C \lambda_i (1-r_i(S^e)) $$</p>
<p>其中，$s_r$ 是一个规则得分因子，用来表示包 $S^e$ 满足规则的程度，$C$ 是正则化参数， $\lambda_i$ 是关系 $i$ 的规则的置信度。</p>
<p>显然，Corpus-Net 的预测结果和 KG-Net 的预测结果具有不同的倾向性，所以需要一个协同模块将这两者结合到一起。我们把两个基础网络的预测记为 $p^c$ 和 $p^k$，在双向知识蒸馏的指导思想下，将两个基础网络的训练目标分别改写为以下形式：</p>
<p>$$ L_c = \sum_{i=1}^N(l(y_i, p_i^c) + \pi_c l(p_i^k, p_i^c)), \quad  L_k = \sum_{i=1}^N(l(y_i, p_i^k) + \pi_k l(p_i^c, p_i^k)) $$    </p>
<p>其中，$l$ 为交叉熵损失， $\pi$ 为模仿率（Imitation Rate），这个双向知识蒸馏的过程不仅从ground truth中学习到相应的知识，还将另外一个网络的预测结果当做另一种形式的ground truth进行学习，$\pi$ 可以被理解为预测结果的置信度。显然，这两个基础网络事先需要预训练。此外，我们希望 $\pi$ 与对应基础网络和ground truth的交叉熵损失成反比，即，当前网络的损失越小，就越具有指导另一个基础网络的资格：</p>
<p>$$ \pi_c = \frac {l(y_i, p_i^k)} {l(y_i, p_i^c) + l(y_i, p_i^k)}, \quad \pi_k = \frac {l(y_i, p_i^c)} {l(y_i, p_i^c) + l(y_i, p_i^k)}$$    </p>
<p>在最终的联合预测上，使用了两个基础网络的预测结果的联合：</p>
<p>$$p^{co} = (1-w_k)p^c+w_kp^k, \quad w_k = \alpha + \beta (\frac{s_r} {n_r} - \frac {n_c}  {n_e\times N_e}) $$</p>
<p>其中，$\alpha$ 是KG-Net的经验权重，$\beta$ 是自由调节权重， $n_r, n_c, n_e, N_e$ 分别是关系的数量，所有候选实体的数量，句子中实体的数量和，候选实体的数量上限。</p>
<h4 id="实验-3"><a href="#实验-3" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集上进行，首先比较了CORD的方法和传统方法在 PR 曲线上的性能，随后探讨了实体向量的不同预训练方式对KG-Net的影响，最后还探讨了在知识蒸馏模块使用不同的模仿率、静态和动态的联合预测对最终结果的影响。</p>
<p><img src="http://qiniu.zzysay.cn/15519457845589.jpg" alt=""></p>
<p>上图的结果表明，Corpus-Net和传统的注意力机制的方法效果相近，因为只是编码器的CNN换成了GRU，KG-Net 的效果超过了基于特征的方法，这似乎表明它们捕获的都是一些特定的模式，所以具有较高的准确率和较低的召回率，最终，CORD的方法达到了最好的效果，虽然提升不是很大。</p>
<p><img src="http://qiniu.zzysay.cn/15519457945842.jpg" alt=""><br>根据上图可以看出，加入关系类型的约束对长尾数据有很大提升（$\ge 1$表示使用整个测试集， $&gt; 1$ 表示过滤掉那些实体对只出现过一次的情况）。这是一种很符合直觉的结果，因为长尾关系的训练相对不充分，加入额外的约束就显得十分有用。 </p>
<h3 id="COLING-2018-DesRC"><a href="#COLING-2018-DesRC" class="headerlink" title="[COLING 2018] DesRC"></a>[COLING 2018] DesRC</h3><blockquote>
<p><strong>Neural Relation Classification with Text Descriptions</strong></p>
</blockquote>
<p>这是来自东北大学知识图谱组的工作，针对关系抽取中的数据稀疏性问题，提出了一个DesRC模型，借助注意力机制将实体的文本描述作为额外信息加入到了句子向量中去。在训练过程中，论文还使用了一些对抗方法来提高模型的鲁棒性。</p>
<h4 id="模型-4"><a href="#模型-4" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519459138774.jpg" alt=""></p>
<p>模型的输入包括三个部分，原句子和两个实体的描述信息。对于关系分类来说，<a href="http://aclweb.org/anthology/P16-1072.pdf" target="_blank" rel="noopener">BRCNN</a> 是目前表现最好的一种句子编码器，输入的是两个实体之间的最短依存路径（SDP），由于实体描述信息中通常只有一个我们关注的实体，无法抽取SDP，所以只能使用CNN来进行编码。在输入部分，依旧使用词向量和位置向量相结合的方法，只是对于描述信息，我们只关注到当前实体的距离。</p>
<p>文章使用单词级别的注意力机制来调整原始的词向量，使那些与实体对和关系相关的单词权重更高。对于句子中的单词 $w$，取其$m$个上下文单词来计算新的词表示 $x$：</p>
<p>$$ x = \sum_i \alpha_i \cdot  w_i; \quad \alpha_i = \frac {\exp(f_i)} {\sum_j\exp(f_j)} $$</p>
<p>其中，$f_j$ 是一个衡量当前词和句子关系$r$以及句子中实体（对）之间的语义相关性的函数，对于原句子和描述信息分别有不同的计算方式：</p>
<p>$$ f_i = \tanh(W \cdot [w_i;w_{e1};w_{e2}]+ U \cdot r) \quad or \quad f_i = \tanh(W_{1/2} \cdot [w_i;w_{e1}/w_{e2}]+ U \cdot r) $$</p>
<p>将调整后的词向量输入到编码器中，分别得到句子和描述信息的向量表示，在这里使用了一个句子级别的注意力机制把句子和描述信息的向量合并为一个全局向量：</p>
<p>$$ s = \sum_i \alpha_i \cdot  s_i; \quad \alpha_i = \frac {\exp(g_i)} {\sum_j \exp(g_j)}; \quad g_i = s_i \cdot  r $$</p>
<p>这就相当于是把每一个样本都转化为一个原始的句子向量和两个描述向量，然后使用注意力把向量加权相加，最后就可以使用这个全局向量进行关系分类。</p>
<p>前人的工作表明在词向量级别加入一些对抗噪声的时候，通常可以获得更好的实验效果，论文同样也做了这样的尝试：</p>
<p>$$ w_i = w_i + v_i; \quad v_i = \epsilon \cdot  g/||g||; \quad where\; g = \partial L/ \partial w_i $$</p>
<h4 id="实验-4"><a href="#实验-4" class="headerlink" title="实验"></a>实验</h4><p>实验在 SemEval-2010 Task 8 上进行，文章首先使用该控制变量的词项逐一探讨模型中各个模块对实验效果的影响，即文本描述信息的重要度、两个注意力机制的影响和对抗训练的影响，最后和当前的基线方法做了对比，</p>
<center><br><img src="http://qiniu.zzysay.cn/15519459378535.jpg" width="400/"><br></center>


<p>相较于BRCNN，本文取得了约1个点的提升，下方4组实验表明可以发现，BRCNN比CNN有明显提升，加入实体描述信息也对实验效果有明显提升。其中，WordNet指的是将实体在WordNet中上位词的词向量与实体向量进行拼接。</p>
<h3 id="EMNLP-2018-HATT"><a href="#EMNLP-2018-HATT" class="headerlink" title="[EMNLP 2018] HATT"></a>[EMNLP 2018] HATT</h3><blockquote>
<p><strong>Hierarchical Relation Extraction with Coarse-to-Fine Grained Attention</strong></p>
</blockquote>
<p>这是来自清华大学刘知远老师组的工作，之前的工作中，关系都是被独立处理的，但是知识库中的关系往往具有层级结构。文章提出了一种层级注意力机制来关注关系之间的层级关系，使得高层次的关系具有更多的训练数据，从而可以获得更好的性能。</p>
<h4 id="模型-5"><a href="#模型-5" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519460227458.jpg" alt=""></p>
<p>模型包括一个句子编码器和一个从粗到细的层级注意力机制，句子编码器使用CNN或PCNN来编码句子，层级注意力机制来选择那些最能表达这个关系的示例。底层的注意力关注的是具体关系的特征，是一种细粒度的样例选择，和传统的方法并无二致，高层的注意力关注的是关系之间的共同特征，是一种粗粒度的样例选择，因为顶层的关系具有足够多的训练数据，所以对长尾关系有很大程度的性能提升。</p>
<p>记实体对 ($h,t$) 对应的句子包为 $S_{h,t}$，关系的全集为 $R$。框架输出层通过加权句子向量得到两个实体之间的文本关系向量 $r_{h,t}$，随后根据这个文本关系向量计算当前向量对知识库关系的得分，得分最高的即为预测出来的关系：</p>
<p>$$ r_{h,t} = \sum_{i=1}^m \alpha_is_i, \; s_1, … , s_m \in S_{h,t}; \quad \quad P(r|h,t,S_{h,t}) = \frac {\exp(o_r)} {\sum_{r^{‘}\in R}\exp(o_{r^{‘}})}, \; o = Mr_{h,t} $$</p>
<p>文章的重点则是对不同的层级使用不用的注意力权重 $\alpha_i$ 来计算 $r_{h,t}$，为了方便叙述，我们定义，给定一个查询向量 $q$， $r_{h,t} = ATT(q, S_{h,t})$。</p>
<p>假设关系的层级结构是树形的，/location/province/capital 为低层次关系，/location 为高层次关系。记 $R^0 = R$，然后迭代 $k-1$ 次，生成 $k$ 个等级的关系集合 ${R^0, R^1,…, R^{k-1}}$。对于一个关系 $r=r^0 \in R = R^0$，通过回溯关系层级树就可以找到它的上层关系：$(r^0, …, r^{k-1}) \in R^0 \times … \times R^{k-1}$，其中，$r^{i-1}$ 是 $r^{i}$ 的子关系。</p>
<p>在计算层级注意力的时候，对每一层的每一个关系都指定一个查询向量，然后利用当前关系的所有句子来计算文本关系向量，最后把各层的文本关系向量拼接起来，就可以得到最终的文本关系向量。</p>
<p>$$ r_{h,t}^i = ATT(q_{r^i}, S_{h,t}); \quad r_{h,t} = [r_{h,t}^0;…;r_{h,t}^{k-1}] $$</p>
<p>这样的一个直观解释就是，对于/location/province/capital的实体对，同样具有/location/province和/location关系，/location的训练数据也会包括/location/contains下的关系，所以就具有更多的训练数据，最后是把所有层级的向量拼接到一起，很显然，这种做法可以提高那些细粒度的长尾关系的识别率。</p>
<h4 id="实验-5"><a href="#实验-5" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集上进行，如上文例子中所述的那样，NYT数据集中的关系本身就具有层级。首先分别使用 PR 曲线和 P@N 指标和基线模型对比，来表明当前模型的优越性，随后分开探讨了层级注意力机制对不同关系的影响，尤其是在长尾关系上。最后做了样例分析，来展示高层次关系和低层次关系关注的不同点。</p>
<p><img src="http://qiniu.zzysay.cn/15519460582502.jpg" alt=""></p>
<p>由上图中的图 3 可以看出，HATT方法和对应的基础方法相比，具有很大程度上的提升，显然，这种程度的提升远不是长尾数据能够带来的，论文也通过实验给出了说明，对于普通的关系，Hits@K平均都有10个点的提升。上图中的表 3 分析了训练数据少于 100/200 条的关系的表现性能，可以看出，传统的方法几乎不能处理此类数据，加入HATT策略可以给此类数据带来成倍的性能提升。 </p>
<h3 id="EMNLP-2018-RESIDE"><a href="#EMNLP-2018-RESIDE" class="headerlink" title="[EMNLP 2018] RESIDE"></a>[EMNLP 2018] RESIDE</h3><blockquote>
<p><strong>RESIDE: Improving Distantly-Supervised Neural Relation Extraction using Side Information</strong></p>
</blockquote>
<p>这是来自Indian Institute of Science的工作，论文使用关系别名和实体类型这两种知识库知识来辅助解决远程监督关系抽取问题。在自然语言场景中，不同的句子对关系的表达方式不尽相同，这种关系别名的信息在关系抽取中十分重要。同时，因为每种关系对应的实体类型都是有限的，所以实体类型在关系抽取中也扮演着不可或缺的角色。</p>
<h4 id="模型-6"><a href="#模型-6" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519462041036.jpg" alt=""></p>
<p>模型首先对句子进行编码，编码过程中，不仅按照传统方法将词向量和位置向量拼接后输入到 Bi-GRU 中得到 $h^{gru}$，同时也在句法依存树上使用 GCN 来获得每个单词的句法知识，记作 $h^{gcn}$，其中，GCN的输入就是 $h^{gru}$。将这两者拼接后使用一个单词级别的注意力机制就可以得到句子的向量表示（其中，$r$ 是一个随机初始化的查询向量）：</p>
<p>$$ s = \sum_{j=1}^m \alpha_i h_i^{concat}; \quad \alpha_i = \frac {\exp(h_i^{concat} · r)} {\sum_j \exp(h_j^{concat} · r)}; \quad h_i^{concat} = [h_i^{gcn};h_i^{gru}] $$</p>
<p><img src="http://qiniu.zzysay.cn/15519462125899.jpg" alt=""></p>
<p>对于关系别名的信息，模型首先使用斯坦福的 Open IE 工具来抽取两个实体之间的关系短语集合 $P$。对于知识库关系，使用 PPDB 将其扩充到一个更大的知识库关系别名集合 $R$，随后把 $P$ 和 $R$ 映射到同一个语义空间中，对于 $P$ 中的每个关系短语 $p$，从集合 $R$ 中选出与其最相近的知识库关系 $h^{rel}$（$|P|&gt;1$时，把所有的$h^{rel}$取平均），最后，$h^{rel}$ 被拼接到句子向量 $s$ 之后，得到新的句子表示 $\hat{s}$。</p>
<p>对于实体类型的信息，使用一个外部工具包 FIGER 来获取Freebase中的实体类型，对每个实体类型，指定一个实体类型向量 $h^{type}$，如果一个实体属于多个类型，就把多个类型的向量取平均，然后把这个向量拼接到包向量上，进行最后的关系分类：</p>
<p>$$ B = \sum_i \alpha_i \hat{s_i}; \quad \hat{s_i} = [s_i; h_i^{rel}]; \quad \alpha_i = \frac {\exp(\hat{s_i}·q)} {\sum_j \exp(\hat{s_j}·q)}, \; \text{where q is a random query vector.} $$<br>$$ \quad \hat{B} = [B; h_{sub}^{type}; h_{obj}^{type}];  \quad p(y) = softmax(W·\hat{B}+b);$$</p>
<h4 id="实验-6"><a href="#实验-6" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT (Riedel) 数据集和 GDS (Google Distant Supervision) 数据集上进行，对比了 RESIDE 和传统方法的表现性能，探讨了在关系别名部分是否使用 PPDB （即知识库关系别名空间的大小）对最终结果的影响。</p>
<p><img src="http://qiniu.zzysay.cn/15519462237052.jpg" alt=""></p>
<p>通过上图的实验结果可以看出，在关系抽取任务中加入关系别名和实体类型的外部知识可以显著提升模型的性能，尤其是在高召回的场景下，准确率的提升十分可观：文中给出的结论是 P@100 的提升大约在2个百分点，P@300 的提升达到了 5 个以上的百分点。最后，实验还通过 Ablation Study 分析了不同因素对模型效果的提升，最后得出 RA &gt; GCN &gt; ET 的结论。</p>
<hr>
<p><a href="https://arxiv.org/pdf/1804.06987.pdf" target="_blank" rel="noopener">GDS</a> 是基于Google关系抽取语料集构建的一个远程监督数据集，保证了每个包中至少含有一个表达当前关系的实例，所以不需要人工评测 P@N 的准确性。GDS 共包含 perGraduatedInstitution、perHasDegree、perPlaceOfBirth、perPlaceOfDeath和NA五种关系，类别分布相对较均衡，每类大约有4k条句子，2k对实体。</p>
<hr>
<h2 id="关系重叠"><a href="#关系重叠" class="headerlink" title="关系重叠"></a>关系重叠</h2><h3 id="IJCAI-2018-PartialMax"><a href="#IJCAI-2018-PartialMax" class="headerlink" title="[IJCAI 2018] PartialMax"></a>[IJCAI 2018] PartialMax</h3><blockquote>
<p><strong>Exploring Encoder-Decoder Model for Distant Supervised Relation Extraction</strong></p>
</blockquote>
<p>这是来自北京邮电大学的工作，文章使用编码解码框架来解决实体对的多关系问题。通常来讲，实体对之间的关系都具有依赖性，已知两个实体具有某种关系对预测其它关系而言是一种十分重要的信息。文章设计了一种方法来决定关系的预测顺序，并将上一个时间步预测出的关系作为下一个时间步的输入，从而实现对关系依赖的建模。</p>
<h4 id="模型-7"><a href="#模型-7" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519463790659.jpg" alt=""></p>
<p>模型使用CNN来编码句子得到向量表示$x_i$，进而得到包的向量表示 $B$，解码器使用 LSTM 来建模关系之间的联系，解码器的输出应该是一个关系的集合。对于第 $t$ 个时间步，LSTM 解码器的隐层状态 $s_t$ 和输出 $y_t = l_j$ 的概率可以使用以下方法来计算（其中，$l_j \in L$ 是第 $j$ 个关系）：</p>
<p>$$ s_t = LSTM(s_{t-1}, y_{t-1}, B) ;\quad p(y_t=l_j|{y_1, …, y_{t-1}}, B) = \frac {\exp(l_jTs_t)} {\sum_r \exp(l_rTs_t)} $$</p>
<p>在得到每一个时间步的输出之后，模型需要重点关注那些关系还尚未被预测出来的句子，这里使用一个注意力机制来动态调整包的向量表示，来降低那些关系已经被预测出来的句子的权重，在注意力权重时，使用了一个神经网络 $\eta$ 来计算当前句子向量$x_i$和解码器上一时刻隐状态 $s_{t-1}$ 的相似度：</p>
<p>$$ B_t = \sum_i \beta_{ti} x_i; \quad \beta_{ti} = \frac {\exp(\eta (s_{t-1}, x_i))} {\sum_j \exp(\eta (s_{t-1}, x_j))} $$</p>
<p>目前，框架还剩下一个重要的问题，就是如何确定关系预测的顺序，因为具有更多信息的关系应当被更早地识别出来并且用作做下一步预测的先验知识。在训练时，预测顺序是通过对每个包中关系的“信息量”来确定的。在测试时，输入只有一个实体对对应的句子包，模型需要自动判断每个关系的信息量然后按照降序预测。</p>
<p>训练集中信息量（IQ）的计算分两步进行，第一步计算句子表示和关系向量的匹配度： $W = XM$，其中 $X\in R^{n\times d^s}$ 是句子表示的矩阵，$M\in R^{d^s\times n_l}$ 是预训练关系向量的矩阵，$n$ 是包中句子的数量，$d^s$ 是句子和关系向量的维度，$n_l$ 是关系的数量。第二步使用局部池化根据匹配得分来计算每个句子的权重，我们用 $W_{ij}$ 来表示达第 $i$ 个句子和第 $j$ 个关系的匹配度，用$L^+$来表示给定句子包的所有关系:</p>
<p>$$  IQ_j = \sum_{i=1}^n \alpha_i W_{ij}; \quad \alpha_i = \frac {\exp(e_i)} {\sum_k\exp(e_k)}; \quad e_i = \max(W_{ij}); \quad i = 1,2,…,n, j \in L^+ $$</p>
<p>最后，对于包向量的初始化，文章给出了两种计算方法：</p>
<p>$$ B_0 = \frac {1} {n} \sum_{i=1}^n x_i; \quad B_0 = \sum_{i=1}^n \alpha_i x_i $$</p>
<p>训练损失使用的是均方误差：</p>
<p>$$ L_{squared} = \sum_{t=1}^{n_B} \sum_{i=1}^{n_l} (q_{ti} - p_{ti})^2 $$</p>
<p>其中，$n_B$ 是包中对应关系的数量，$n_l$ 是总的关系数量。$q_{ti} \in {0,1}$ 是 $t$ 时间第 $i$ 个关系的标签， $p_{ti}$ 是 $t$ 时间第 $i$ 个关系的预测概率。训练时，对每个包的关系末尾增加了一个 <end>，测试时，当解码器输出5个关系或输出<end>后即停止。</end></end></p>
<h4 id="实验-7"><a href="#实验-7" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集上进行，分别使用 PR 曲线和 P@N 两种指标来评价模型性能。</p>
<p><img src="http://qiniu.zzysay.cn/15519463923015.jpg" alt=""></p>
<p>由上图可以看出，Partial+IQ+ATT 达到了一个很优异的效果，相较于基线模型提高了近10个点。其中，Ave 和 Partial 指包向量的两种初始化方法，Freq 指根据关系频率降序来确定关系预测顺序，ATT指在解码器中加入注意力机制来调整包的表示。</p>
<h3 id="ACL-2018-MultiDecoder"><a href="#ACL-2018-MultiDecoder" class="headerlink" title="[ACL 2018] MultiDecoder"></a>[ACL 2018] MultiDecoder</h3><blockquote>
<p><strong>Extracting Relational Facts by an End-to-End Neural Model with Copy Mechanism</strong></p>
</blockquote>
<p>这是来自自动化所刘康老师组的工作，通常来讲，一个句子中会含有很多的实体三元组，但是以往的工作常常忽略了这一点。文章基于编码解码模型，主要关注三元组中实体和实体对的重叠（同一个实体或实体对参与多个关系）的情况。</p>
<h4 id="模型-8"><a href="#模型-8" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519464573760.jpg" alt=""></p>
<p><img src="http://qiniu.zzysay.cn/15519464657890.jpg" alt=""></p>
<p>给定一个句子 $s=[x_1,…,x_n]$，编码器使用一个Bi-RNN来对句子进行编码，在 $t$ 时刻，得到其输出 $o_t^E$ 和隐藏状态 $h_t^E$：$o_t^E, h_t^E = f(x_i, h_{t-1}^E)$。解码器直接生成关系的三元组，每三个时间步为一个周期，每三个时间步为一个周期，第一个时间步，使用编码器的输出来预测关系，产生一个新的三元组，第二个时间步，从源句子中复制第一个实体，第三个时间步，从源句子中复制第二个实体。不断重复这个过程，就可以生成很多的三元组，最后输出一个NA标签来标志解码结束。</p>
<p>使用单解码器时，在 $t$ 时刻，记作其输出 $o_t^D$ 和隐藏状态 $h_t^D$：$o_t^D, h_t^D = f(u_t, h_{t-1}^D)$，其中，$u_t = [v_t;c_t]·W^u$，$v_t$ 是上一个时间步复制过来的实体的向量或者预测的关系的向量，$c_t$ 是一个注意力向量：</p>
<p>$$ c_t = \sum_{i=1}^n \alpha_i \times o_i^E; \quad \alpha_i = softmax(\beta);\quad \beta_i = selu([h_{t-1}^D; o_i^E]·w^c) $$</p>
<p>在第 $t$（$t\%3=1$） 个时间步，计算关系的置信度向量 $q^r = [q_1^r,…,q_m^r]$，选择概率最大的关系作为输出，并将这个关系向量作为下一个时间步的$v_{t+1}$，实现对关系的拷贝：</p>
<p>$$ q^r = selu(o_t^D·W^r + b^r);\quad q^{na} = selu(o_t^D·W^{na} + b^{na}); \quad p^r = softmax([q^r; q^{na}]) $$</p>
<p>在第 $t$（$t\%3=2$） 个时间步，根据句子中的每个单词计算实体的置信度向量 $q^e = [q_1^e,…,q_n^e]$，选择概率最大的实体作为输出，并将这个实体向量作为下一个时间步的$v_{t+1}$，实现对实体的拷贝：</p>
<p>$$  q^e_i = selu([o_t^D;o_i^E]·w^c); \quad p^e = softmax([q^e; q^{na}]) $$</p>
<p>在第 $t$（$t\%3=0$） 个时间步，复制第二个实体和复制第一个实体的过程几乎完全相同，区别在于对 $q^e$ 乘了一个mask来避免选中第一个实体：</p>
<p>$$ M_i = \begin{cases} 1, i \neq k \\ 0, i = k \end{cases}; \quad p^e = softmax([M \otimes q^e; q^{na}]) $$</p>
<p>单解码器模型中，解码器的最初输入是句子向量，多解码器模型中，每隔三个时间步，都使用一个新的解码器，并且重新输入一次原始的句子向量，把句子向量和上一时刻的隐层状态取平均作为当前解码器的输入。显然，这是一种更好的方法，相对只使用一个编码器可以有效避免错误传播的问题。</p>
<h4 id="实验-8"><a href="#实验-8" class="headerlink" title="实验"></a>实验</h4><p>实验在 NYT 数据集和 WebNLG 数据集上进行，作者人工过滤掉了NYT 中不包含实体三元组的句子和长度大于100的句子，最后使用56195条作为训练，5000条作为验证，5000条作为测试。文章选取了一个17年的<a href="http://aclweb.org/anthology/D17-1182.pdf" target="_blank" rel="noopener">工作</a>作为基线，实验的重点在于探讨单编码器和多编码器的区别和模型对不同重叠程度数据的处理情况。</p>
<p>文章把句子分成了三类，一类是实体没有重叠（Normal），一类是实体对完全重叠（EntityPairOverlap, EPO），还有一类是单实体重叠（SingleEntityOverlap. SEO）。</p>
<p><img src="http://qiniu.zzysay.cn/15519465874810.jpg" alt=""></p>
<p>实验结果表明，模型提出的两种方法在这两个数据集上都取得了卓越的性能，文章提出的方法在实体无重叠的情况下，并没有超过基线模型，但是在实体有重叠的场景，各项指标都遥遥领先。最后，实验还展示了句子中三元组的数量对关系抽取性能的影响，并且对比了单解码器和多解码器在拷贝时的准确率。</p>
<hr>
<p><a href="http://aclweb.org/anthology/P17-1017.pdf" target="_blank" rel="noopener">WebNLG</a>是为自然语言生成准备的数据集，其中包括 246种关系，在这个数据集中，每个示例都包括一组三元组和一些对应的（标准人工）句子，每个句子中都包含示例中所有的三元组，论文对其进行了一系列过滤，最后剩下训练数据5019条，验证数据500条，测试数据703条。</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="EMNLP-2018-C-GCN"><a href="#EMNLP-2018-C-GCN" class="headerlink" title="[EMNLP 2018] C-GCN"></a>[EMNLP 2018] C-GCN</h3><blockquote>
<p><strong>Graph Convolution over Pruned Dependency Trees Improves Relation Extraction</strong></p>
<p>这是来自Stanford University / Manning 老师组的工作，句子的句法依存树对关系分类来说是一种十分重要的信息，但传统的神经网络模型很难直接高效地处理此类信息，GCN作为CNN在图上的扩展，天然地适合处理这种非欧的结构。同时，为了更好地利用这种树状结构，文章还提出了一种以路径为核心的剪枝策略来降低噪声词的影响。</p>
</blockquote>
<h4 id="模型-9"><a href="#模型-9" class="headerlink" title="模型"></a>模型</h4><p><img src="http://qiniu.zzysay.cn/15519466599452.jpg" alt=""></p>
<p>直接在句子的依存树上使用 GCN 会面临两个问题：句子表示倾向于大度节点而忽略其他小度节点的信息，并且低层的隐状态不会被传递到高层，因为在依存树中节点不会和自己相连。文章使用两种策略来解决这两个问题：对隐层状态除以节点的度、给每个节点增加一个自环。我们定义 $A$ 为原始邻接矩阵，增加自环后 $\tilde{A} = A + I$，$d_i = \sum_j \tilde{A_{ij}}$。记第 $l$ 层的第 $i$ 个节点的输入为 $h^{(l-1)}_i$, 输出为 $h^{(l)}_i$，于是有：</p>
<p>$$ h^{(l)}_i = \sigma (\sum_{j=1}^n A_{ij}W^{(l)}h_{j}^{(l-1)} + b^{(l)}) \quad \rightarrow \quad  h^{(l)}_i = \sigma (\sum_{j=1}^n \tilde{A_{ij}}W^{(l)}h_{j}^{(l-1)} / d_i + b^{(l)})  $$</p>
<p>按照上图所示的模型，将句子中的每个单词转化成其词向量 $h^{0}$，经过 GCN 得到新的词表示 $h^{(L)}$，接最大池化层得到句子表示 $h_{sent}$。此外，还将 GCN 输出层中与头尾实体位置对应的单词单独取出进行最大池化，分别得到头尾实体的向量表示 $h_o$，$h_s$。最后把这三个向量首尾拼接进行关系分类：$ h_{final} = FFNN([h_{sent};h_{s};h_{o}]) $。</p>
<p>GCN无法编码长距离信息，并且完全依赖于依存树的结构，这可能会放大句法分析带来的噪声，为了解决以上问题，模型在词向量层和图卷积层之间增加了一层 Bi-LSTM 来编码单词的上下文信息，最终得到C-GCN模型。</p>
<p>文章提出了一种以依存路径为核心的剪枝，引入一个变量 $K$ 来衡量单词到 SDP 的距离。当$K=0$时，只保留 SDP 上的节点，当$K=\infty$ 时，则保留 LCA 上的全部节点，当$K=1$ 时，即保留 SDP 及其一阶邻居节点。</p>
<h4 id="实验-9"><a href="#实验-9" class="headerlink" title="实验"></a>实验</h4><p>实验在 SemEval 2010 Task 8 和 TACRED 上进行，实验和分析十分详实，实验部分的侧重点在于展示模型在这两个数据集上的结果，并探讨 $K$ 值对模型结果的影响。</p>
<p><img src="http://qiniu.zzysay.cn/15519466710066.jpg" alt=""></p>
<p>如上图中的表1和表2所示，在两个数据集上，C-GCN的方法相较于 PA-LSTM 的方法都取得了大约1个点的提升，作者认为，这两种方法虽然性能相近，但是在数据处理上是互补的，于是引出了 C-GCN + PA-LSTM的Ensemble方法和下文对这两类模型的分析。下图中的图3展示了验证集上的 $F_1$ 值随着 $K$ 取值的变化情况，当$K=1$，即保留 SDP 及其一阶邻居节点时，所有的模型都达到了最好的效果。</p>
<center><br><img src="http://qiniu.zzysay.cn/15519466837523.jpg" width="400/"><br></center>

<p>最后，文章针对模型和任务进行了全面的分析和讨论，首先，Ablation Study的结果表明，剪枝策略对模型的影响很大；随后 Case Study表明基于依存结构的模型可以更好的处理两个实体距离较远的情况，序列模型可以更好地捕获到上下文模式；最后使用可视化的方式展示了 C-GCN 预测正确的样例的情况。</p>
<hr>
<p><a href="http://aclweb.org/anthology/D17-1004.pdf" target="_blank" rel="noopener">TACRED</a> 是Stanford在2017年发布的一个新的（精标）远程监督关系抽取数据集，使用TAC KBP 2009-2012年的语料作为训练集，2013年的语料作为验证集，2014年的语料作为测试集。最终的共包括 42 个关系，100对实体，约12w句子。</p>
<hr>
<h3 id="Additional"><a href="#Additional" class="headerlink" title="Additional"></a>Additional</h3><p>除了以上10篇文章，2018年还有很多极具代表性的工作，有的提出了一些新的问题，有的给传统问题提供了一种新思路，还有的使用了一些新的模型。在本小节，我们额外选取了6篇工作，对它们分别进行简略的介绍。</p>
<blockquote>
<p><strong>Joint Extraction of Entities and Relations Based on a Novel Graph Scheme</strong></p>
</blockquote>
<p>这是来自哈尔滨工业大学刘挺老师组的工作，通讯作者是西湖大学的张岳老师。论文面向实体和关系的联合抽取任务，提出了一种基于图结构的联合方法，针对标注方案不能抽取一个句子中包含多个关系的场景，图结构构建了实体弧和关系弧，每个节点都可能有多个关系弧。在将一句话转化成一个初始状态之后，模型使用贪心的方法，根据当前状态从预先定义的状态中选择下一个动作，直至终止状态。状态的定义和从句子到图的转化，整体来看是借鉴前人的工作，但是却是首次应用到关系抽取领域，并且取得了很好的效果。</p>
<blockquote>
<p><strong>Ranking-Based Automatic Seed Selection and Noise Reduction for Weakly Supervised Relation Extraction</strong></p>
</blockquote>
<p>这是来自Nara Institute of Science and Technology的工作，文章创造性地将关系抽取中的自动选种和数据降噪任务转换为排序问题。然后借鉴 HITS、K-means、LSA 和 NMF 等传统策略，按照对(S,P,O)三元组排序的思路，构建出了兼具自动选种和数据降噪功能的算法。实验结果表明，文章提出的算法能够有效完成这两个任务，并且其性能也有较大提升。这篇文章的启发在于，对于关系抽取中的各种子任务，可以通过问题转换的方式，将其归约到具有成熟解决方案的传统问题中去，而后借鉴已有的算法设计出通用的解决策略，这种思路上的开拓创新是值得思考和探索的。</p>
<blockquote>
<p><strong>Exploratory Neural Relation Classification for Domain Knowledge Acquisition</strong></p>
</blockquote>
<p>这是来自华东师范大学的工作，近几年来，关系分类任务主要利用神经网络模型来自动学习复杂的特征。然而这类监督式学习方法的局限性在于，它需要大量训练数据，并且特定领域存在长尾的低频关系无法被有效地预定义。本论文提出了基于领域知识获取的探索式关系分类任务。目标在于学习预定义关系的分类器的同时，从文本中发现新的语义关系。文章提出了一个动态结构的神经网络，可以对持续扩充的关系集进行分类。并进一步提出了相似度敏感的中餐馆过程算法，用于发现新关系。基于大语料库上的实验证明了该神经网络的分类效果，同时新发现的关系也有较高的准确率和召回率。</p>
<blockquote>
<p><strong>Attention-Based Capsule Networks with Dynamic Routing for Relation Extraction</strong></p>
</blockquote>
<p>这是来自阿里巴巴-浙江大学前沿技术联合研究中心的工作，合作作者还有阿里巴巴知识图谱团队负责人张伟（览图）。当前神经网络依旧面临着一些问题，一个是当前的模型十分依赖于句子表示的质量，使用向量来表示句子是十分受限的；另一个是CNN的子采样无法保证高维特征中各个部分之间的联系，胶囊网络的提出就是为了解决以上两个问题，正如Hinton所说，胶囊网络天然地适合处理重复的数据（重叠的图片，重叠的语义）。作者把胶囊网络应用到多示例多标签的关系抽取上，模型首先使用Bi-LSTM来编码句子，随后就是传统的胶囊网络模型在关系抽取任务上的简单修改，实验在两个公开数据集上进行，相较于传统方法，胶囊网络取得了十分可观的提升。</p>
<blockquote>
<p><strong>N-ary Relation Extraction using Graph State LSTM</strong></p>
</blockquote>
<p>这是来自西湖大学张岳老师组的工作，文章面向跨句子的多元关系抽取，提出了一种基于图状态转移的方法，模型基于Tree LSTM和图循环神经网络，在每个时间步实现每个节点和与其直连节点之间的信息交互，和前人的工作不同，使用这种图方法可以直接把句子的依存图输入到模型中，对于每个单词，将其拆分成出度节点和入度节点，从而增强节点之间的联系。实验结果表明，这种图方法比传统的树方法和序列方法在性能上都有很大程度的提升。</p>
<blockquote>
<p><strong>FewRel: A Large-Scale Supervised Few-Shot Relation Classification Dataset with State-of-the-Art Evaluation</strong></p>
</blockquote>
<p>这是来自清华大学刘知远老师组的工作，文章面向少样本学习场景，提出了一个大规模有监督的关系分类数据集FewRel，并在这个数据集上系统地实现了近年来少样本学习的典型方法。作者首先使用远程监督构建了一个大规模的候选句子集合，然后针对每个关系，人工地筛选出了那些标签错误的句子，最后得到的FewRel共含有70000条句子，100个关系，每个关系含有700条句子。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纵观整个基于深度学习的关系抽取的发展情况，在2018年以前，关系抽取领域面临的问题主要有两个，正如 Manning 在 EMNLP 2017 上的<a href="http://aclweb.org/anthology/D17-1004.pdf" target="_blank" rel="noopener">一篇论文</a>的观点：1) 之前的模型不足以适用于关系抽取任务；2) 缺少满足当前深度模型训练的标注数据，那篇文章也针对这两个点都做了一些改进，并发布了一个数据集 TACRED。整体来看，2018年关系抽取也主要都在解决这两个问题，研究者们开始关注句法结构这一在关系抽取任务中十分重要的信息，同时很多工作也使用或发布了一些新的数据集。除此之外，对于知识库知识的利用是在 2018 年得以长足发展的一个研究点，这个研究点会持续不断地发展下去，可以预见，这种 “知识+模型” 的方法将会应用到其他的自然语言处理任务中。目前自然语言处理任务中利用的知识多为语义特征标签，关系抽取领域利用知识库知识的工作仍旧停留在向量拼接的阶段，知识库知识的利用绝不限于此，我们应该用一种更有效的方法将其应用到更广泛的任务中去。</p>
<p>不得不提的是，顶会上关于关系抽取的文章也越来越多，更多的人开始关注这一领域。综合来看，关系抽取接下来的发展方向可以概括为以下三个部分：1) 更先进的方法：强化学习，生成对抗网络，图卷积网络，胶囊网络；2) 更广的抽取范围：实体关系联合抽取，单句子多关系同时抽取，篇章级关系抽取；c) 更少的标注数据：无监督的关系抽取，少样本的关系抽取。AAAI 2019录取的文章也表达出了这个趋势，其中不乏一些使用新模型或者提出新问题的工作。</p>
<center><br><a href="http://qiniu.zzysay.cn/DL4RE2018@zzy.pdf" target="_blank" rel="noopener">点击这里可下载 PDF 版本</a><br></center>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/自然语言处理/" rel="tag"># 自然语言处理</a>
              <a href="/tags/知识图谱/" rel="tag"># 知识图谱</a>
              <a href="/tags/关系抽取/" rel="tag"># 关系抽取</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/01/nlp-dl4re-v1/" rel="prev" title="基于深度学习的关系抽取发展历程(2014-2018)">
      <i class="fa fa-chevron-left"></i> 基于深度学习的关系抽取发展历程(2014-2018)
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍"><span class="nav-number">1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型去噪"><span class="nav-number">2.</span> <span class="nav-text">模型去噪</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AAAI-2018-CNN-RL"><span class="nav-number">2.1.</span> <span class="nav-text">[AAAI 2018] CNN+RL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型"><span class="nav-number">2.1.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验"><span class="nav-number">2.1.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACL-2018-DSGAN"><span class="nav-number">2.2.</span> <span class="nav-text">[ACL 2018] DSGAN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EMNLP-2018-STP-TL"><span class="nav-number">2.3.</span> <span class="nav-text">[EMNLP 2018] STP+TL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外部知识"><span class="nav-number">3.</span> <span class="nav-text">外部知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#COLING-2018-CORD"><span class="nav-number">3.1.</span> <span class="nav-text">[COLING 2018] CORD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-3"><span class="nav-number">3.1.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-3"><span class="nav-number">3.1.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COLING-2018-DesRC"><span class="nav-number">3.2.</span> <span class="nav-text">[COLING 2018] DesRC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-4"><span class="nav-number">3.2.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-4"><span class="nav-number">3.2.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EMNLP-2018-HATT"><span class="nav-number">3.3.</span> <span class="nav-text">[EMNLP 2018] HATT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-5"><span class="nav-number">3.3.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-5"><span class="nav-number">3.3.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EMNLP-2018-RESIDE"><span class="nav-number">3.4.</span> <span class="nav-text">[EMNLP 2018] RESIDE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-6"><span class="nav-number">3.4.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-6"><span class="nav-number">3.4.2.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系重叠"><span class="nav-number">4.</span> <span class="nav-text">关系重叠</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IJCAI-2018-PartialMax"><span class="nav-number">4.1.</span> <span class="nav-text">[IJCAI 2018] PartialMax</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-7"><span class="nav-number">4.1.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-7"><span class="nav-number">4.1.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ACL-2018-MultiDecoder"><span class="nav-number">4.2.</span> <span class="nav-text">[ACL 2018] MultiDecoder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-8"><span class="nav-number">4.2.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-8"><span class="nav-number">4.2.2.</span> <span class="nav-text">实验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EMNLP-2018-C-GCN"><span class="nav-number">5.1.</span> <span class="nav-text">[EMNLP 2018] C-GCN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-9"><span class="nav-number">5.1.1.</span> <span class="nav-text">模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验-9"><span class="nav-number">5.1.2.</span> <span class="nav-text">实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Additional"><span class="nav-number">5.2.</span> <span class="nav-text">Additional</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhenyu Zhang"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Zhenyu Zhang</p>
  <div class="site-description" itemprop="description">Survival with technology<br/>And living with art</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhenyu Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
